export default async function dailyRotation (apiConfig) { const aa = Object.defineProperty; const ie = (t) => (e) => { const a = t[e]; if (a) return a(); throw new Error("Module not found in bundle: " + e); }; const c = (t, e) => () => (t && (e = t(t = 0)), e); const l = (t, e) => { for (const a in e)aa(t, a, { "get": e[a], "enumerable": !0 }); }; const R = {}; l(R, { "errorStatus": () => ia }); let ia; const L = c(() => { ia = { "status": !0, "lastError": {}, "errorList": [] }; }); const ne = {}; l(ne, { "formError": () => na }); async function na (t, e) { let { "errorStatus": a } = await Promise.resolve().then(() => (L(), R)); e = e === "unknown" ? "unknown" : `${e}.js`; let i = new Error().stack.toString().match(/([A-Za-z0-9_$-]+) \(([^)]+)\)/g); i.splice(0, 2); let s = []; for await (let m of i) { let u = m.split(" "); let w = u[0]; let p = u[1].replace(/[()]/g, "").split("/"); let y = p[p.length - 1].split(":")[0]; s.push({ "function": w, "file": y }); } let o = { "code": t, "functionName": s[0].function, "currentName": s[0].file, "originalName": e }; console.log(o), t !== "warning" && (a.status = !1), a.lastError = o, a.errorList.push(o); } const re = c(() => {}); const b = {}; l(b, { "patterns": () => ra }); let ra; const v = c(() => { ra = { "pattern1": /[^a-zA-Z]+/g, "pattern2": /\s{2,}/g, "pattern3": /\s/g, "pattern4": /^[A-Za-z0-9]+$/i, "pattern5": /^[A-Za-z0-9\s]+$/i, "pattern6": /([Zz]|[+-]\d{2}:\d{2})$/, "pattern7": /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])(?:[Tt ]([01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?)?(?:[Zz]|[+-][01]\d:[0-5]\d)?$/, "pattern8": /^(0[1-9]|[12]\d|3[01])-(0[1-9]|1[0-2])-(\d{4})(?:[Tt ]([01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?)?(?:[Zz]|[+-][01]\d:[0-5]\d)?$/, "pattern9": /^([+-])?(90(\.0{1,7})?|([0-9]|[1-8][0-9])(\.\d{1,7})?)$/, "pattern10": /^([+-])?(180(\.0{1,7})?|([0-9]|[1-9][0-9]|1[0-7][0-9])(\.\d{1,7})?)$/, "pattern11": /^(?:[A-Za-z]+(?: [A-Za-z]+)*), (?:[A-Za-z]+(?: [A-Za-z]+)*)$/i, "pattern12": /^0?([1-9]|1[0-2]):([0-5]?[0-9]):([0-5]?[0-9])\s?(AM|PM)$/, "pattern13": /^0?([1-9]|1[0-9]|2[0-3]):([0-5]?[0-9]):([0-5]?[0-9])$/, "pattern14": /^(Africa|Antarctica|Atlantic|Australia|Indian|Europe|Asia)\/[A-Za-z0-9_\-+]+$/i, "pattern15": /^(America|Pacific)\/[A-Za-z0-9_\-+]+(?:\/[A-Za-z0-9_\-+]+)?$/i, "pattern16": /^Etc\/(UTC|GMT[+-]?\d{0,2})$/i }; }); const k = {}; l(k, { "typeID": () => sa }); async function sa (t) { let { "patterns": e } = await Promise.resolve().then(() => (v(), b)); return Object.prototype.toString.call(t).split(" ")[1].replace(e.pattern1, "").toLowerCase(); } const N = c(() => {}); const j = {}; l(j, { "spaceFormat": () => oa }); async function oa (t, e) { let { "patterns": a } = await Promise.resolve().then(() => (v(), b)); return e === "singleSpace" ? String(t).replace(a.pattern2, " ") : e === "noSpace" ? String(t).replace(a.pattern3, "") : (await errorHandle(4531, "spaceFormat"), !1); } const x = c(() => {}); const S = {}; l(S, { "isNully": () => ca }); async function ca (t) { let { "typeID": e } = await Promise.resolve().then(() => (N(), k)); let { "spaceFormat": a } = await Promise.resolve().then(() => (x(), j)); switch (await e(t)) { case "number": return isNaN(t); case "null": case "undefined": return !0; case "string": return (await a(String(t), "singleSpace")).trim().length === 0; default: return !1; } } const A = c(() => {}); const d = {}; l(d, { "errorHandle": () => la }); async function la (t, e) { let { "errorStatus": a } = await Promise.resolve().then(() => (L(), R)); let { "formError": n } = await Promise.resolve().then(() => (re(), ne)); let { "isNully": r } = await Promise.resolve().then(() => (A(), S)); if (await r(t)) await n("unknown", "unknown"); else { if (t === "status") return !!a.status; (await r(e)) || (t === "warning" ? await n(t, e) : t >= 1111 && t <= 9999 ? await n(t, e) : await n("unknown", "unknown")); } } const f = c(() => {}); const U = {}; l(U, { "conditionString": () => ua }); async function ua (t, e) { let { "typeID": a } = await Promise.resolve().then(() => (N(), k)); let { "spaceFormat": n } = await Promise.resolve().then(() => (x(), j)); if ((await a(t)) === "string") { let r = await n(String(t), "singleSpace"); switch (String(e)) { case "1": return !0; default: return r.trim().length > 0; } } else return !1; } const E = c(() => {}); const se = {}; l(se, { "conditionArray": () => ma }); async function ma (t, e) { let { "typeID": a } = await Promise.resolve().then(() => (N(), k)); if ((await a(t)) === "array") switch (String(e)) { case "1": return !0; default: return t.length !== 0; } else return !1; } const oe = c(() => {}); const ce = {}; l(ce, { "conditionObject": () => da }); async function da (t, e) { let { "typeID": a } = await Promise.resolve().then(() => (N(), k)); if ((await a(t)) === "object") switch (String(e)) { case "1": return !0; default: return Object.keys(t).length > 0 && Object.values(t).length > 0; } else return !1; } const le = c(() => {}); const K = {}; l(K, { "conditionNumber": () => fa }); async function fa (t, e) { let { "typeID": a } = await Promise.resolve().then(() => (N(), k)); if ((await a(t)) === "number") switch (String(e)) { case "1": return !0; default: return isNaN(t) === !1; } else return !1; } const B = c(() => {}); const Y = {}; l(Y, { "conditionBoolean": () => wa }); async function wa (t) { let { "typeID": e } = await Promise.resolve().then(() => (N(), k)); return (await e(t)) === "boolean"; } const G = c(() => {}); const ue = {}; l(ue, { "conditionUndefined": () => pa }); async function pa (t) { let { "typeID": e } = await Promise.resolve().then(() => (N(), k)); return (await e(t)) === "undefined"; } const me = c(() => {}); const de = {}; l(de, { "conditionNull": () => ga }); async function ga (t) { let { "typeID": e } = await Promise.resolve().then(() => (N(), k)); return (await e(t)) === "null"; } const fe = c(() => {}); const g = {}; l(g, { "conditionCheck": () => ha }); async function ha (t, e, a) { let { "conditionString": n } = await Promise.resolve().then(() => (E(), U)); let { "conditionArray": r } = await Promise.resolve().then(() => (oe(), se)); let { "conditionObject": i } = await Promise.resolve().then(() => (le(), ce)); let { "conditionNumber": s } = await Promise.resolve().then(() => (B(), K)); let { "conditionBoolean": o } = await Promise.resolve().then(() => (G(), Y)); let { "conditionUndefined": m } = await Promise.resolve().then(() => (me(), ue)); let { "conditionNull": u } = await Promise.resolve().then(() => (fe(), de)); switch (e) { case "string": return await n(t, a); case "array": return await r(t, a); case "object": return await i(t, a); case "number": return await s(t, a); case "boolean": return await o(t); case "undefined": return await m(t); case "null": return await u(t); } } const h = c(() => {}); const pe = {}; l(pe, { "flatternObject": () => we }); async function we (t, e = "", a = {}, n = new Set) { for await (let r of Object.keys(t)) { let i = t[r]; if (i && typeof i == "object" && !Array.isArray(i)) await we(i, r, a, n); else { let s = n.has(r) ? `${e}.${r}` : r; a[s] = i, n.add(r); } } return a; } const ge = c(() => {}); const q = {}; l(q, { "addressNames": () => ya }); let ya; const J = c(() => { ya = { "parents": {}, "children": { "item1": { "name": { "original": "addresstype", "altName": "addressType" }, "used": !1, "validate": "" }, "item2": { "name": { "original": "boundingbox", "altName": "boundingBox" }, "used": !1, "validate": "" }, "item3": { "name": { "original": "category", "altName": "category" }, "used": !1, "validate": "" }, "item4": { "name": { "original": "display_name", "altName": "displayName" }, "used": !0, "validate": "checkAddress" }, "item5": { "name": { "original": "importance", "altName": "importance" }, "used": !1, "validate": "" }, "item6": { "name": { "original": "lat", "altName": "lat" }, "used": !0, "validate": "checkAddress" }, "item7": { "name": { "original": "licence", "altName": "licence" }, "used": !1, "validate": "" }, "item8": { "name": { "original": "lon", "altName": "lon" }, "used": !0, "validate": "checkAddress" }, "item9": { "name": { "original": "name", "altName": "name" }, "used": !1, "validate": "" }, "item10": { "name": { "original": "osm_id", "altName": "osm_id" }, "used": !1, "validate": "" }, "item11": { "name": { "original": "osm_type", "altName": "osm_type" }, "used": !1, "validate": "" }, "item12": { "name": { "original": "place_id", "altName": "place_id" }, "used": !1, "validate": "" }, "item13": { "name": { "original": "place_rank", "altName": "place_rank" }, "used": !1, "validate": "" }, "item14": { "name": { "original": "type", "altName": "type" }, "used": !1, "validate": "" } } }; }); const C = {}; l(C, { "patternTest": () => ka }); async function ka (t, e, a, n) { let { "errorHandle": r } = await Promise.resolve().then(() => (f(), d)); let { "patterns": i } = await Promise.resolve().then(() => (v(), b)); return i[e].test(t) ? t : (await r(a, n), !1); } const H = c(() => {}); const he = {}; l(he, { "checkAddress": () => Na }); async function Na (t, e, a) { let { "isNully": n } = await Promise.resolve().then(() => (A(), S)); let { "patternTest": r } = await Promise.resolve().then(() => (H(), C)); if (await n(e)) return "No Value"; switch (e = String(e), t) { case a.children.item4.name.altName: return await r(e, "pattern11", 7839, "checkAddress"); case a.children.item6.name.altName: return await r(e, "pattern9", 5762, "checkAddress"); case a.children.item8.name.altName: return await r(e, "pattern10", 6079, "checkAddress"); } } const ye = c(() => {}); const I = {}; l(I, { "objectLoop": () => ke }); async function ke (t) { let { "typeID": e } = await Promise.resolve().then(() => (N(), k)); let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), g)); let { "errorHandle": n } = await Promise.resolve().then(() => (f(), d)); if (await n("status")) { if ((await a(t, "object")) === !1) return 0; let r = 0; let i = Object.keys(t); for await (let s of i) { let o = t[s]; let m = await e(o); let u; switch (m) { case "string": case "number": case "bigint": case "boolean": case "undefined": case "array": case "null": { u = await a(o, m, 1); break; } default: u = !1; }(await a(o, "object")) ? r += await ke(o) : u && (r += 1); } return r; } else return await n(7826, "objectLoop"), !1; } const z = c(() => {}); const Q = {}; l(Q, { "supportedAddress": () => ba }); let ba; const W = c(() => { ba = ["tokyo, japan", "new york, united states", "oslo, norway", "Copenhagen, Denmark", "Seoul, South Korea", "Los Angeles, United States", "London, United Kingdom", "Paris, France", "Toronto, Canada", "Stockholm, Sweden", "Helsinki, Finland", "Berlin, Germany", "Sydney, Australia", "Auckland, New Zealand", "Abchorage, Alaska"]; }); const F = {}; l(F, { "validAddress": () => va }); async function va (t) { let { "supportedAddress": e } = await Promise.resolve().then(() => (W(), Q)); let { "errorHandle": a } = await Promise.resolve().then(() => (f(), d)); let { "patterns": n } = await Promise.resolve().then(() => (v(), b)); let { "spaceFormat": r } = await Promise.resolve().then(() => (x(), j)); let { "conditionCheck": i } = await Promise.resolve().then(() => (h(), g)); if (await i(t, "string")) { let s = (await r(String(t), "singleSpace")).toLowerCase(); if (n.pattern11.test(s) === !0) { let o = []; for await (let u of e) { let w = u.split(",")[0].trim().toLowerCase(); o.push(w); } let m; for await (let u of o) if (s.includes(u)) for await (let w of e)w.toLowerCase().includes(u) && (m = w.toLowerCase()); return m || (await a(9101, "validAddress"), !1); } else return await a(3512, "validAddress"), !1; } else return await a(1265, "validAddress"), !1; } const $ = c(() => {}); const Ne = {}; l(Ne, { "checkResult": () => ja }); async function ja (t, e) { let { "errorHandle": a } = await Promise.resolve().then(() => (f(), d)); let n = t?.headers.get("content-type"); if (n && n?.includes("application/json")) try { let r = JSON.parse(e); return r || (await a(6054, "checkResult"), !1); } catch { return await a(1834, "checkResult"), !1; } else return await a(4003, "checkResult"), !1; } const be = c(() => {}); const T = {}; l(T, { "attemptFetch": () => xa }); async function xa (t) { let { "checkResult": e } = await Promise.resolve().then(() => (be(), Ne)); let { "errorHandle": a } = await Promise.resolve().then(() => (f(), d)); let n = 5; let r = !1; for (;n-- && r === !1;) { try { let i = await fetch(t); if (i.ok) { r = !0; let s = await i.text(); return await e(i, s); } else await a("warning", "attemptFetch"); } catch { if (n === 0) return await a(9858, "attemptFetch"), !1; } await new Promise((i) => setTimeout(i, 200)); } } const O = c(() => {}); const ve = {}; l(ve, { "fetchAddress": () => Sa }); async function Sa (t) { let { "validAddress": e } = await Promise.resolve().then(() => ($(), F)); let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), g)); let { "errorHandle": n } = await Promise.resolve().then(() => (f(), d)); let { "attemptFetch": r } = await Promise.resolve().then(() => (O(), T)); if (await a(t, "string")) { let i = await e(String(t)); let s = encodeURI(`https://nominatim.openstreetmap.org/search?q=${i}&format=jsonv2&limit=1`); let o = await r(s); return (await a(o, "array")) ? (o[0].display_name = i, o) : (await n(8443, "fetchAddress"), !1); } else return await n(6975, "fetchAddress"), !1; } const je = c(() => {}); const X = {}; l(X, { "getAddress": () => Aa }); async function Aa (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let { "sendProcess": a } = await Promise.resolve().then(() => (D(), _)); let { "conditionCheck": n } = await Promise.resolve().then(() => (h(), g)); let { "objectLoop": r } = await Promise.resolve().then(() => (z(), I)); let { "fetchAddress": i } = await Promise.resolve().then(() => (je(), ve)); let { "addressNames": s } = await Promise.resolve().then(() => (J(), q)); if (!(await e("status"))) return !1; let o = await i(t); if (o) { let m = o[0]; if (await n(m, "object")) { let u = await r(m); let p = await a({ "address": { "type": "object", "value": m }, "amount": { "type": "number", "value": u }, "name": { "type": "object", "value": s } }); return p || (await e(5645, "getAddress"), !1); } else return await e(7209, "getAddress"), !1; } else return await e(5657, "getAddress"), !1; } const V = c(() => {}); const tt = {}; l(tt, { "manageAddress": () => Ia }); async function Ia (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let { "getAddress": a } = await Promise.resolve().then(() => (V(), X)); if (!(await e("status"))) return !1; let n = await a(t); return n || (await e(2856, "manageAddress"), !1); } const et = c(() => {}); const xe = {}; l(xe, { "checkDate": () => za }); async function za (t, e, a) { let { "isNully": n } = await Promise.resolve().then(() => (A(), S)); let { "patternTest": r } = await Promise.resolve().then(() => (H(), C)); if (await n(e)) return "No Value"; switch (e = String(e), t) { case a.children.item1.name.altName: switch (e) { case "today": case "yesterday": case "tomorrow": return await r(e, "pattern5", 4334, "checkDate"); default: return await r(e, "pattern7", 2663, "checkDate"); } } } const Se = c(() => {}); const at = {}; l(at, { "dateFormat": () => _a }); async function _a (t) { let { "patterns": e } = await Promise.resolve().then(() => (v(), b)); let { "errorHandle": a } = await Promise.resolve().then(() => (f(), d)); let n = t.replace(e.pattern6, ""); if (e.pattern8.test(n)) { let r = n.split("-").reverse().join("-"); return (new Date(r).getDate() ? r : !1) ? r : (await a(8353, "dateFormat"), !1); } else return await a(8524, "dateFormat"), !1; } const it = c(() => {}); const nt = {}; l(nt, { "dateNames": () => Da }); let Da; const rt = c(() => { Da = { "parents": {}, "children": { "item1": { "name": { "original": "date", "altName": "date" }, "used": !0, "validate": "checkDate" } } }; }); const Ae = {}; l(Ae, { "checkIdentifier": () => Ra }); async function Ra (t, e, a) { let { "isNully": n } = await Promise.resolve().then(() => (A(), S)); let { "patterns": r } = await Promise.resolve().then(() => (v(), b)); if (await n(e)) return "No Value"; switch (e = String(e), t) { case a.children.item1.name.altName: { let i = ["pattern14", "pattern15", "pattern16"]; for await (let s of i) if (r[s].test(e)) return e; } } } const Ie = c(() => {}); const ze = {}; l(ze, { "fetchIdentifier": () => La }); async function La (t) { let { "conditionCheck": e } = await Promise.resolve().then(() => (h(), g)); let { "errorHandle": a } = await Promise.resolve().then(() => (f(), d)); let { "attemptFetch": n } = await Promise.resolve().then(() => (O(), T)); if (await e(t, "object")) { let r = encodeURI(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${t.lat}&longitude=${t.lon}`); let i = await n(r); return (await e(i, "object")) ? i : (await a(7043, "fetchIdentifier"), !1); } else return await a(8063, "fetchIdentifier"), !1; } const _e = c(() => {}); const st = {}; l(st, { "identifierNames": () => Ca }); let Ca; const ot = c(() => { Ca = { "parents": {}, "children": { "item1": { "name": { "original": "identifier", "altName": "identifier" }, "used": !0, "validate": "checkIdentifier" } } }; }); const De = {}; l(De, { "validString": () => Ha }); async function Ha (t, e) { let { "typeID": a } = await Promise.resolve().then(() => (N(), k)); let { "conditionBoolean": n } = await Promise.resolve().then(() => (G(), Y)); let { "conditionNumber": r } = await Promise.resolve().then(() => (B(), K)); let { "conditionString": i } = await Promise.resolve().then(() => (E(), U)); switch (await a(t)) { case "number": return await r(t, e); case "string": return await i(t, e); case "boolean": return await n(t, e); } } const Re = c(() => {}); const ct = {}; l(ct, { "callObject": () => Ta }); async function Ta (t, e) { let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), g)); let { "errorHandle": n } = await Promise.resolve().then(() => (f(), d)); let r = (await a(t, "object")) ? t : !1; let i = (await a(e, "string")) ? e : !1; if (r && i) try { return await e.split(".").reduce(async (s, o) => s[o], t); } catch { return await n(8002, "callObject"), !1; } else return await n(1742, "callObject"), !1; } const lt = c(() => {}); const Ce = {}; l(Ce, { "findObject": () => Le }); async function Le (t, e, a = []) { let { "validString": n } = await Promise.resolve().then(() => (Re(), De)); let { "callObject": r } = await Promise.resolve().then(() => (lt(), ct)); if (t && typeof t == "object") for await (let i of Object.keys(t)) { let s = t[i]; let o = (await n(e)) ? String(e).toLowerCase() : !1; let m = (await n(i)) ? String(i).toLowerCase() : !1; let u = (await n(s)) ? String(s).toLowerCase() : !1; if ((u && o || m && o) && (u === o || m === o)) return { "parent": t, "path": a.concat(i), "value": await r(t, String(a.concat(i).slice(-1))) }; let w = await Le(s, e, a.concat(i)); if (w) return w; } return !1; } const He = c(() => {}); const ut = {}; l(ut, { "getIdentifier": () => Oa }); async function Oa (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let { "sendProcess": a } = await Promise.resolve().then(() => (D(), _)); let { "conditionCheck": n } = await Promise.resolve().then(() => (h(), g)); let { "objectLoop": r } = await Promise.resolve().then(() => (z(), I)); let { "fetchIdentifier": i } = await Promise.resolve().then(() => (_e(), ze)); let { "identifierNames": s } = await Promise.resolve().then(() => (ot(), st)); let { "findObject": o } = await Promise.resolve().then(() => (He(), Ce)); if (!(await e("status"))) return !1; let m = await i(t); if (m) { let u = (await o(m, "time zone"))?.parent; if (u) { let w = Object.keys(u)[0]; let p = { "identifier": u[w] }; if (await n(p, "object")) { let y = await r(p); let P = await a({ "identifier": { "type": "object", "value": p }, "amount": { "type": "number", "value": y }, "name": { "type": "object", "value": s } }); return P ? P.identifier : (await e(5645, "getDate"), !1); } else return await e(3597, "getIdentifier"), !1; } else return await e(5465, "getIdentifier"), !1; } else return await e(6788, "getIdentifier"), !1; } const mt = c(() => {}); const dt = {}; l(dt, { "manageIdentifier": () => Pa }); async function Pa (t, e) { let { "errorHandle": a } = await Promise.resolve().then(() => (f(), d)); let { "getIdentifier": n } = await Promise.resolve().then(() => (mt(), ut)); if (!(await a("status"))) return !1; let r; return e === "local" ? r = await n(t) : r = { "identifier": e }, r || (await a(6491, "manageIdentifier"), !1); } const ft = c(() => {}); const wt = {}; l(wt, { "addressInput": () => Fa }); async function Fa (t) { let { "spaceFormat": e } = await Promise.resolve().then(() => (x(), j)); let { "errorHandle": a } = await Promise.resolve().then(() => (f(), d)); let { "validAddress": n } = await Promise.resolve().then(() => ($(), F)); let { "conditionCheck": r } = await Promise.resolve().then(() => (h(), g)); if (await r(t, "string")) { let i = await n(String(t)); if (i) { let s = (await e(String(i), "singleSpace")).toLowerCase(); return s || (await a(3797, "addressInput"), !1); } else return await a(3374, "addressInput"), !1; } else return await a(2428, "addressInput"), !1; } const pt = c(() => {}); const gt = {}; l(gt, { "dateInput": () => $a }); async function $a (t) { let { "spaceFormat": e } = await Promise.resolve().then(() => (x(), j)); let { "errorHandle": a } = await Promise.resolve().then(() => (f(), d)); let { "patterns": n } = await Promise.resolve().then(() => (v(), b)); let { "dateFormat": r } = await Promise.resolve().then(() => (it(), at)); let { "conditionCheck": i } = await Promise.resolve().then(() => (h(), g)); if (await i(t, "string")) { let s; if (n.pattern4.test(t))s = t; else if (n.pattern7.test(t) || n.pattern8.test(t)) { let o = t.replace(n.pattern6, ""); n.pattern8.test(t) ? s = await r(o) : s = o; } else return await a(2064, "dateInput"), !1; if (s) { let o = (await e(String(s), "singleSpace")).toLowerCase(); return o || (await a(4374, "dateInput"), !1); } else return await a(2978, "dateInput"), !1; } else return await a(3799, "dateInput"), !1; } const ht = c(() => {}); const yt = {}; l(yt, { "timezoneInput": () => Ma }); async function Ma (t) { let { "spaceFormat": e } = await Promise.resolve().then(() => (x(), j)); let { "errorHandle": a } = await Promise.resolve().then(() => (f(), d)); let { "patterns": n } = await Promise.resolve().then(() => (v(), b)); let { "conditionCheck": r } = await Promise.resolve().then(() => (h(), g)); if (await r(t, "string")) { let i; if (t === "local")i = t; else { let s = ["pattern14", "pattern15", "pattern16"]; for await (let o of s)n[o].test(t) && (i = t); } if (i) { let s = await e(String(i), "singleSpace"); return s || (await a(9706, "timezoneInput"), !1); } else return await a(6447, "timezoneInput"), !1; } else return await a(3620, "timezoneInput"), !1; } const kt = c(() => {}); const Nt = {}; l(Nt, { "manageBase": () => Za }); async function Za (t, e) { let { "errorHandle": a } = await Promise.resolve().then(() => (f(), d)); let { "callObject": n } = await Promise.resolve().then(() => (lt(), ct)); let { "conditionCheck": r } = await Promise.resolve().then(() => (h(), g)); let i = {}; let s = {}; if (!(await a("status"))) return !1; if (r(t, "object")) { for await (let o of Object.keys(e)) { if (!(await a("status"))) return !1; i[o] = !1; let m = await n(t, o); if (r(m, "string")) { let u = m.toLowerCase(); let w = await e[o](u); w && (i[o] = !0, s[o] = w); } else return await a(4278, "manageBase"), !1; } return Object.values(i).includes(!1) ? (await a(3603, "manageBase"), !1) : s; } } const bt = c(() => {}); const vt = {}; l(vt, { "baseInput": () => Ua }); async function Ua (t) { let { "dateInput": e } = await Promise.resolve().then(() => (ht(), gt)); let { "addressInput": a } = await Promise.resolve().then(() => (pt(), wt)); let { "timezoneInput": n } = await Promise.resolve().then(() => (kt(), yt)); let { "manageBase": r } = await Promise.resolve().then(() => (bt(), Nt)); return await r(t, { "date": e, "address": a, "timezone": n }); } const jt = c(() => {}); const xt = {}; l(xt, { "resultObj": () => Ea }); async function Ea (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let a = String(t.itemData.altName); let n = t.value; let r = await t.validateImport[t.validateValue](a, n, t.nameImport[t.nameValue]); if (r) { let i = t.result; for await (let s of t.path) if (await e("status")) { let o = s; if (t.parentNames.includes(o)) { let m = t.parentList[t.parentNames.indexOf(o)]; m.used && (o = m.altName); }i[o] ? i = i[o] : i = i[o] = {}; } else return await e(9450, "resultObj"), !1; return i[t.itemData.altName] = r, t.result; } else return await e(8125, "resultObj"), !1; } const St = c(() => {}); const Te = {}; l(Te, { "checkRotation": () => Ka }); async function Ka (t, e, a) { let { "isNully": n } = await Promise.resolve().then(() => (A(), S)); let { "patternTest": r } = await Promise.resolve().then(() => (H(), C)); if (await n(e)) return "No Value"; switch (e = String(e), t) { case a.children.item1.name.altName: case a.children.item2.name.altName: case a.children.item3.name.altName: case a.children.item5.name.altName: case a.children.item6.name.altName: case a.children.item7.name.altName: case a.children.item8.name.altName: case a.children.item9.name.altName: case a.children.item10.name.altName: return await r(e, "pattern12", 2123, "checkRotation"); case a.children.item4.name.altName: return await r(e, "pattern13", 3084, "checkRotation"); } } const Oe = c(() => {}); const Pe = {}; l(Pe, { "fetchRotation": () => Ba }); async function Ba (t) { let { "conditionCheck": e } = await Promise.resolve().then(() => (h(), g)); let { "errorHandle": a } = await Promise.resolve().then(() => (f(), d)); let { "attemptFetch": n } = await Promise.resolve().then(() => (O(), T)); if (await e(t, "object")) { let r = encodeURI(`https://api.sunrise-sunset.org/json?lat=${t.lat}&lng=${t.lon}&date=${t.date}&tzid=${t.timezone}`); let i = await n(r); return (await e(i, "object")) ? i : (await a(5547, "fetchRotation"), !1); } else return await a(6205, "fetchRotation"), !1; } const Fe = c(() => {}); const At = {}; l(At, { "rotationNames": () => Ya }); let Ya; const It = c(() => { Ya = { "parents": {}, "children": { "item1": { "name": { "original": "sunrise", "altName": "sunrise" }, "used": !0, "validate": "checkRotation" }, "item2": { "name": { "original": "sunset", "altName": "sunset" }, "used": !0, "validate": "checkRotation" }, "item3": { "name": { "original": "solar_noon", "altName": "solar_noon" }, "used": !0, "validate": "checkRotation" }, "item4": { "name": { "original": "day_length", "altName": "day_length" }, "used": !0, "validate": "checkRotation" }, "item5": { "name": { "original": "civil_twilight_begin", "altName": "civil_twilight_begin" }, "used": !0, "validate": "checkRotation" }, "item6": { "name": { "original": "civil_twilight_end", "altName": "civil_twilight_end" }, "used": !0, "validate": "checkRotation" }, "item7": { "name": { "original": "nautical_twilight_begin", "altName": "nautical_twilight_begin" }, "used": !0, "validate": "checkRotation" }, "item8": { "name": { "original": "nautical_twilight_end", "altName": "nautical_twilight_end" }, "used": !0, "validate": "checkRotation" }, "item9": { "name": { "original": "astronomical_twilight_begin", "altName": "astronomical_twilight_begin" }, "used": !0, "validate": "checkRotation" }, "item10": { "name": { "original": "astronomical_twilight_end", "altName": "astronomical_twilight_end" }, "used": !0, "validate": "checkRotation" } } }; }); const zt = {}; l(zt, { "getRotation": () => Ga }); async function Ga (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let { "sendProcess": a } = await Promise.resolve().then(() => (D(), _)); let { "conditionCheck": n } = await Promise.resolve().then(() => (h(), g)); let { "objectLoop": r } = await Promise.resolve().then(() => (z(), I)); let { "fetchRotation": i } = await Promise.resolve().then(() => (Fe(), Pe)); let { "rotationNames": s } = await Promise.resolve().then(() => (It(), At)); if (!(await e("status"))) return !1; let o = await i(t); if (o) { let m = o.results; if (await n(m, "object")) { let u = await r(m); let p = await a({ "rotation": { "type": "object", "value": m }, "amount": { "type": "number", "value": u }, "name": { "type": "object", "value": s } }); return p ? p.rotation : (await e(5645, "getRotation"), !1); } else return await e(3110, "getRotation"), !1; } else return await e(7887, "getRotation"), !1; } const _t = c(() => {}); const Dt = {}; l(Dt, { "manageRotation": () => qa }); async function qa (t, e, a) { let { "errorHandle": n } = await Promise.resolve().then(() => (f(), d)); let { "getRotation": r } = await Promise.resolve().then(() => (_t(), zt)); if (!(await n("status"))) return !1; let i = { "lat": t.lat, "lon": t.lon, "timezone": e.identifier, "date": a.date }; let s = await r(i); return s || (await n(9955, "manageRotation"), !1); } const Rt = c(() => {}); const Lt = {}; l(Lt, { "timeDifference": () => Ja }); async function Ja (t, e) { let a; let n; let r; if (t > e ? (r = "behind", a = new Date(e), n = new Date(t)) : (r = "ahead", a = new Date(t), n = new Date(e)), isNaN(a) || isNaN(n)) return null; let i = { "years": n.getFullYear() - a.getFullYear(), "months": n.getMonth() - a.getMonth(), "days": n.getDate() - a.getDate(), "hours": n.getHours() - a.getHours(), "minutes": n.getMinutes() - a.getMinutes(), "seconds": n.getSeconds() - a.getSeconds(), "milliseconds": n.getMilliseconds() - a.getMilliseconds() }; if (i.milliseconds < 0 && (i.milliseconds += 1e3, i.seconds--), i.seconds < 0 && (i.seconds += 60, i.minutes--), i.minutes < 0 && (i.minutes += 60, i.hours--), i.hours < 0 && (i.hours += 24, i.days--), i.days < 0) { let s = new Date(n.getFullYear(), n.getMonth(), 0); i.days += s.getDate(), i.months--; } return i.months < 0 && (i.months += 12, i.years--), i.weeks = Math.floor(i.days / 7), i.days = i.days % 7, i.direction = r, i; } const Ct = c(() => {}); const Ht = {}; l(Ht, { "validDate": () => Qa }); async function Qa (t, e) { let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), g)); return (await a(t, "string")) ? new Date(t).getDate() ? t : !1 : (await errorHandle(e), !1); } const Tt = c(() => {}); const Ot = {}; l(Ot, { "checkDifference": () => Wa }); async function Wa (t, e) { let { "timeDifference": a } = await Promise.resolve().then(() => (Ct(), Lt)); let { "validDate": n } = await Promise.resolve().then(() => (Tt(), Ht)); let { "errorHandle": r } = await Promise.resolve().then(() => (f(), d)); let i = await n(t, 9919, "checkDifference"); let s = await n(e, 5355, "checkDifference"); if (i && s) { let o = await a(i, s); return o || (await r(4715, "checkDifference"), !1); } else return await r(4067, "checkDifference"), !1; } const Pt = c(() => {}); const $e = {}; l($e, { "checkTimezone": () => Xa }); async function Xa (t, e, a) { let { "isNully": n } = await Promise.resolve().then(() => (A(), S)); let { "patternTest": r } = await Promise.resolve().then(() => (H(), C)); let { "patterns": i } = await Promise.resolve().then(() => (v(), b)); if (await n(e)) return "No Value"; switch (e = String(e), t) { case a.children.item1.name.altName: return await r(e, "pattern6", 7535, "checkTimezone"); case a.children.item10.name.altName: case a.children.item11.name.altName: return await r(e, "pattern4", 4668, "checkTimezone"); case a.children.item5.name.altName: case a.children.item6.name.altName: { let s = e.replace(i.pattern6, ""); return await r(s, "pattern7", 3789, "checkTimezone"); } } } const Me = c(() => {}); const Ze = {}; l(Ze, { "fetchTimezone": () => Va }); async function Va (t) { let { "conditionCheck": e } = await Promise.resolve().then(() => (h(), g)); let { "errorHandle": a } = await Promise.resolve().then(() => (f(), d)); let { "attemptFetch": n } = await Promise.resolve().then(() => (O(), T)); if (await e(t, "object")) { let r = encodeURI(`https://worldtimeapi.org/api/timezone/${t.identifier}`); let i = await n(r); return (await e(i, "object")) ? i : (await a(5569, "fetchTimezone"), !1); } else return await a(6189, "fetchTimezone"), !1; } const Ue = c(() => {}); const Ft = {}; l(Ft, { "timezoneNames": () => ti }); let ti; const $t = c(() => { ti = { "parents": {}, "children": { "item1": { "name": { "original": "utc_offset", "altName": "utc_offset" }, "used": !0, "validate": "checkTimezone" }, "item2": { "name": { "original": "timezone", "altName": "timezone" }, "used": !1, "validate": "checkTimezone" }, "item3": { "name": { "original": "day_of_week", "altName": "day_of_week" }, "used": !1, "validate": "checkTimezone" }, "item4": { "name": { "original": "day_of_year", "altName": "day_of_year" }, "used": !1, "validate": "checkTimezone" }, "item5": { "name": { "original": "datetime", "altName": "datetime" }, "used": !0, "validate": "checkTimezone" }, "item6": { "name": { "original": "utc_datetime", "altName": "utc_datetime" }, "used": !0, "validate": "checkTimezone" }, "item7": { "name": { "original": "unixtime", "altName": "unixtime" }, "used": !1, "validate": "checkTimezone" }, "item8": { "name": { "original": "raw_offset", "altName": "raw_offset" }, "used": !1, "validate": "checkTimezone" }, "item9": { "name": { "original": "week_number", "altName": "week_number" }, "used": !1, "validate": "checkTimezone" }, "item10": { "name": { "original": "abbreviation", "altName": "abbreviation" }, "used": !0, "validate": "checkTimezone" }, "item11": { "name": { "original": "dst_offset", "altName": "dst_offset" }, "used": !0, "validate": "checkTimezone" }, "item12": { "name": { "original": "client_ip", "altName": "client_ip" }, "used": !1, "validate": "checkTimezone" }, "item13": { "name": { "original": "dst", "altName": "dst" }, "used": !1, "validate": "checkTimezone" }, "item14": { "name": { "original": "dst_from", "altName": "dst_from" }, "used": !1, "validate": "checkTimezone" }, "item15": { "name": { "original": "dst_until", "altName": "dst_until" }, "used": !1, "validate": "checkTimezone" } } }; }); const Mt = {}; l(Mt, { "getTimezone": () => ei }); async function ei (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let { "sendProcess": a } = await Promise.resolve().then(() => (D(), _)); let { "conditionCheck": n } = await Promise.resolve().then(() => (h(), g)); let { "objectLoop": r } = await Promise.resolve().then(() => (z(), I)); let { "fetchTimezone": i } = await Promise.resolve().then(() => (Ue(), Ze)); let { "timezoneNames": s } = await Promise.resolve().then(() => ($t(), Ft)); let { "checkDifference": o } = await Promise.resolve().then(() => (Pt(), Ot)); if (!(await e("status"))) return !1; let m = await i(t); if (m) { let u = m; if (await n(u, "object")) { let w = await r(u); let y = await a({ "timezone": { "type": "object", "value": u }, "amount": { "type": "number", "value": w }, "name": { "type": "object", "value": s } }); if (y) { let ae = y.timezone.datetime; let P = y.timezone.utc_datetime; return y.timezone.difference = await o(P, ae), y.timezone; } else return await e(5645, "getRotation"), !1; } else return await e(5639, "getTimezone"), !1; } else return await e(6777, "getTimezone"), !1; } const Zt = c(() => {}); const Ut = {}; l(Ut, { "manageTimezone": () => ai }); async function ai (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let { "getTimezone": a } = await Promise.resolve().then(() => (Zt(), Mt)); if (!(await e("status"))) return !1; let n = await a(t); return n || (await e(5868, "manageTimezone"), !1); } const Et = c(() => {}); let Ee; const Kt = c(() => { Ee = ie({ "../manageAddress/addressNames.js": () => Promise.resolve().then(() => (J(), q)), "../manageAddress/checkAddress.js": () => Promise.resolve().then(() => (ye(), he)), "../manageAddress/getAddress.js": () => Promise.resolve().then(() => (V(), X)), "../manageAddress/manageAddress.js": () => Promise.resolve().then(() => (et(), tt)), "../manageAddress/supportedAddress.js": () => Promise.resolve().then(() => (W(), Q)), "../manageAddress/validAddress.js": () => Promise.resolve().then(() => ($(), F)), "../manageDate/checkDate.js": () => Promise.resolve().then(() => (Se(), xe)), "../manageDate/dateFormat.js": () => Promise.resolve().then(() => (it(), at)), "../manageDate/dateNames.js": () => Promise.resolve().then(() => (rt(), nt)), "../manageDate/getDate.js": () => Promise.resolve().then(() => (Xt(), Wt)), "../manageDate/manageDate.js": () => Promise.resolve().then(() => (te(), Vt)), "../manageIdentifier/checkIdentifier.js": () => Promise.resolve().then(() => (Ie(), Ae)), "../manageIdentifier/getIdentifier.js": () => Promise.resolve().then(() => (mt(), ut)), "../manageIdentifier/identifierNames.js": () => Promise.resolve().then(() => (ot(), st)), "../manageIdentifier/manageIdentifier.js": () => Promise.resolve().then(() => (ft(), dt)), "../manageInput/addressInput.js": () => Promise.resolve().then(() => (pt(), wt)), "../manageInput/baseInput.js": () => Promise.resolve().then(() => (jt(), vt)), "../manageInput/dateInput.js": () => Promise.resolve().then(() => (ht(), gt)), "../manageInput/manageBase.js": () => Promise.resolve().then(() => (bt(), Nt)), "../manageInput/timezoneInput.js": () => Promise.resolve().then(() => (kt(), yt)), "../manageProcess/innerLoop.js": () => Promise.resolve().then(() => (Z(), M)), "../manageProcess/loopItem.js": () => Promise.resolve().then(() => (qt(), Gt)), "../manageProcess/objectLoop.js": () => Promise.resolve().then(() => (z(), I)), "../manageProcess/resultObj.js": () => Promise.resolve().then(() => (St(), xt)), "../manageProcess/setupItem.js": () => Promise.resolve().then(() => (Yt(), Bt)), "../manageProcess/setupLoop.js": () => Promise.resolve().then(() => (Qt(), Jt)), "../manageRotation/checkRotation.js": () => Promise.resolve().then(() => (Oe(), Te)), "../manageRotation/getRotation.js": () => Promise.resolve().then(() => (_t(), zt)), "../manageRotation/manageRotation.js": () => Promise.resolve().then(() => (Rt(), Dt)), "../manageRotation/rotationNames.js": () => Promise.resolve().then(() => (It(), At)), "../manageTimezone/checkDifference.js": () => Promise.resolve().then(() => (Pt(), Ot)), "../manageTimezone/checkTimezone.js": () => Promise.resolve().then(() => (Me(), $e)), "../manageTimezone/getTimezone.js": () => Promise.resolve().then(() => (Zt(), Mt)), "../manageTimezone/manageTimezone.js": () => Promise.resolve().then(() => (Et(), Ut)), "../manageTimezone/timeDifference.js": () => Promise.resolve().then(() => (Ct(), Lt)), "../manageTimezone/timezoneNames.js": () => Promise.resolve().then(() => ($t(), Ft)), "../manageTimezone/validDate.js": () => Promise.resolve().then(() => (Tt(), Ht)) }); }); let Bt = {}; l(Bt, { "setupItem": () => ii }); async function ii (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let { "resultObj": a } = await Promise.resolve().then(() => (St(), xt)); let n = Object.keys(t.loop.storage)[0].toLowerCase(); let r = n.charAt(0).toUpperCase() + n.slice(1); let i = n + "Names"; let s = await Ee(`../manage${r}/${i}.js`); let o = t.loop.itemData.validate; let m = await Ee(`../manage${r}/${o}.js`); if (await e("status")) { let u = t.loop.path; let w = t.loop.itemData; if (Number(t.loop.childIndex) === 0 && t.loop.parent !== "" && u.length === 0 && u.push(n), w) { let p = { "itemData": w, "value": t.data.value, "nameValue": i, "nameImport": s, "validateValue": o, "validateImport": m, "parentList": t.loop.parentList, "parentNames": t.loop.parentNames, "result": t.data.result, "path": u }; let y = await a(p); return y || (await e(1207, "setupItem"), !1); } else return await e(9065, "setupItem"), !1; } else return await e(2445, "setupItem"), !1; } let Yt = c(() => { Kt(); }); let Gt = {}; l(Gt, { "loopItem": () => ni }); async function ni (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), g)); let { "setupItem": n } = await Promise.resolve().then(() => (Yt(), Bt)); let { "innerLoop": r } = await Promise.resolve().then(() => (Z(), M)); for await (let i of Object.keys(t.obj)) if (await e("status")) { let s = t.obj[i]; if ((await a(s, "array")) && (s = String(s)), !(await a(s, "object")) && !(await a(s, "array"))) { let o; let m; let u; if (t.loop1.childrenNames.includes(i)) if (m = t.loop1.childrenList[t.loop1.childrenNames.indexOf(i)], m.used) { t.parent = t.parent === "" ? Object.keys(t.storage)[0] : String(t.parent); let w = { "loop": { "parent": t.parent, "storage": t.storage, "childIndex": t.childIndex.counter, "path": t.path, "itemData": m, "parentList": t.loop1.parentList, "parentNames": t.loop1.parentNames }, "data": { "value": s, "result": t.result } }; if (u = await n(w), u)o = "validPass"; else return await e(4313, "loopItem"), !1; } else o = "ignorePass"; else o = "ignorePass"; t.loop1.itemAmount.counter++, o === "validPass" ? (m.status = !0, t.result = u, t.childIndex.counter++) : o === "ignorePass" ? t.childIndex.counter++ : await e(9561, "loopItem"); } else (await a(s, "object")) && (await r(t.loop1, s, t.storage, i, t.result, t.path.concat(i))); } else return await e(8849, "loopItem"), !1; } let qt = c(() => {}); let M = {}; l(M, { "innerLoop": () => ri }); async function ri (t, e, a, n = "", r = {}, i = []) { let { "errorHandle": s } = await Promise.resolve().then(() => (f(), d)); let { "loopItem": o } = await Promise.resolve().then(() => (qt(), Gt)); if (await s("status")) { if (await o({ "loop1": t, "obj": e, "parent": n, "path": i, "childIndex": { "counter": 0 }, "storage": a, "result": r }), Number(a.amount) === Number(t.itemAmount.counter)) { for await (let w of Object.values(t.childrenList)) if (w.used === !0 && w.used !== w.status) return !1; return r; } } else return await s(4780, "innerLoop"), !1; } let Z = c(() => {}); let Jt = {}; l(Jt, { "setupLoop": () => si }); async function si (t, e) { let { "errorHandle": a } = await Promise.resolve().then(() => (f(), d)); let { "flatternObject": n } = await Promise.resolve().then(() => (ge(), pe)); let { "innerLoop": r } = await Promise.resolve().then(() => (Z(), M)); if (await a("status")) { let i = { "counter": 0 }; let s = {}; for await (let u of Object.keys(e.name))s[u] = {}, s[u].list = await Promise.all(Object.values(e.name[u]).map(async (w) => { let p = await n(w); return p.status = !1, p; })), s[u].name = await Promise.all(Object.values(s[u].list).map(async (w) => w.original)); let o = { "itemAmount": i, "childrenList": s.children.list, "childrenNames": s.children.name, "parentList": s.parents.list, "parentNames": s.parents.name }; let m = await r(o, t, e); return m || (await a(2233, "setupLoop"), !1); } else return await a(8194, "setupLoop"), !1; } let Qt = c(() => {}); const Ke = {}; l(Ke, { "valueKind": () => oi }); async function oi (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), g)); let n = {}; let r = {}; for await (let i of Object.keys(t))n[i] = !1; if (await a(t, "object")) { for await (let i of Object.keys(t)) { let s = t[i]; (await a(s.value, s.type)) && (n[i] = !0, r[i] = s.value); } return Object.values(n).includes(!1) ? (await e(3835, "valueKind"), !1) : r; } else return await e(6497, "valueKind"), !1; } const Be = c(() => {}); let _ = {}; l(_, { "sendProcess": () => ci }); async function ci (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), g)); let { "setupLoop": n } = await Promise.resolve().then(() => (Qt(), Jt)); let { "valueKind": r } = await Promise.resolve().then(() => (Be(), Ke)); if (await a(t, "object")) { let i = await r(t); if (i) { let s = Object.keys(t)[0]; let o = await n(i[s], i); return o || (await e(8361, "sendProcess"), !1); } else return await e(9122, "sendProcess"), !1; } else return await e(9122, "sendProcess"), !1; } let D = c(() => {}); const Ye = {}; l(Ye, { "fetchDate": () => li }); async function li (t) { let { "spaceFormat": e } = await Promise.resolve().then(() => (x(), j)); let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), g)); if (await a(t, "string")) { let r = { "date": await e(String(t), "noSpace") }; return (await a(r, "object")) ? r : (await errorHandle(4117, "fetchDate"), !1); } else return await errorHandle(9031, "fetchDate"), !1; } const Ge = c(() => {}); let Wt = {}; l(Wt, { "getDate": () => ui }); async function ui (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let { "sendProcess": a } = await Promise.resolve().then(() => (D(), _)); let { "conditionCheck": n } = await Promise.resolve().then(() => (h(), g)); let { "objectLoop": r } = await Promise.resolve().then(() => (z(), I)); let { "fetchDate": i } = await Promise.resolve().then(() => (Ge(), Ye)); let { "dateNames": s } = await Promise.resolve().then(() => (rt(), nt)); if (!(await e("status"))) return !1; let o = await i(t); if (o) { let m = o; if (await n(m, "object")) { let u = await r(m); let p = await a({ "date": { "type": "object", "value": m }, "amount": { "type": "number", "value": u }, "name": { "type": "object", "value": s } }); return p ? p.date : (await e(5645, "getDate"), !1); } else return await e(5420, "getDate"), !1; } else return await e(5675, "getDate"), !1; } let Xt = c(() => {}); let Vt = {}; l(Vt, { "manageDate": () => mi }); async function mi (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let { "getDate": a } = await Promise.resolve().then(() => (Xt(), Wt)); if (!(await e("status"))) return !1; let n = await a(t); return n || (await e(3394, "manageDate"), !1); } let te = c(() => {}); const qe = {}; l(qe, { "getAPI": () => di }); async function di (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let { "manageDate": a } = await Promise.resolve().then(() => (te(), Vt)); let { "manageAddress": n } = await Promise.resolve().then(() => (et(), tt)); let { "manageIdentifier": r } = await Promise.resolve().then(() => (ft(), dt)); let { "manageTimezone": i } = await Promise.resolve().then(() => (Et(), Ut)); let { "manageRotation": s } = await Promise.resolve().then(() => (Rt(), Dt)); let o = await a(t.date); let m = await n(t.address); let u = await r(m, t.timezone); let w = await i(u); let p = await s(m, u, o); return (await e("status")) ? { "date": o.date, "address": m, "identifier": u.identifier, "timezone": w, "rotation": p } : !1; } const Je = c(() => {}); const Qe = {}; l(Qe, { "resultValue": () => fi }); async function fi (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (f(), d)); let { "errorStatus": a } = await Promise.resolve().then(() => (L(), R)); return (await e("status")) ? { "status": !0, "result": t, "trace": a.errorList } : { "status": !1, "result": t, "trace": a.errorList }; } const We = c(() => {}); const Xe = {}; l(Xe, { "defaultValues": () => wi }); let wi; const Ve = c(() => { wi = { "date": "today", "address": "london, united kingdom", "timezone": "local" }; }); const ta = {}; l(ta, { "initialValue": () => pi }); async function pi (t) { let { "conditionCheck": e } = await Promise.resolve().then(() => (h(), g)); let { "isNully": a } = await Promise.resolve().then(() => (A(), S)); let { "errorHandle": n } = await Promise.resolve().then(() => (f(), d)); let { "defaultValues": r } = await Promise.resolve().then(() => (Ve(), Xe)); let i = (await a(t)) ? {} : t; let s = {}; if (await e(i, "object", 1)) { let o = Object.keys(i); let m = Object.keys(r); if (o.length <= m.length) { for await (let u of m) o.includes(u) ? s[u] = i[u] : o.includes(u) === !1 && (s[u] = r[u]); return s; } else return await n(5465, "initialValue"), !1; } else return await n(7899, "initialValue"), !1; } const ea = c(() => {}); return (async function ee (t) { let { "getAPI": e } = await Promise.resolve().then(() => (Je(), qe)); let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), g)); let { "baseInput": n } = await Promise.resolve().then(() => (jt(), vt)); let { "errorHandle": r } = await Promise.resolve().then(() => (f(), d)); let { "resultValue": i } = await Promise.resolve().then(() => (We(), Qe)); let { "errorStatus": s } = await Promise.resolve().then(() => (L(), R)); let { "initialValue": o } = await Promise.resolve().then(() => (ea(), ta)); let m = await o(t); if (await a(m, "object")) { let u = await n(m); if (!(await r("status"))) return !1; if (u) { let w = await e(u); return w ? await i(w) : (await r(5749, "dailyRotation"), await i(s.lastError)); } else return await r(7987, "dailyRotation"), await i(s.lastError); } else return await r(3136, "dailyRotation"), await i(s.lastError); })(apiConfig); }